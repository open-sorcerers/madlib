// file: path
const toString = (fn, args = []) => () => (
  `curry(${fn.toString()})${args.length > 0 ? `(${args.join(`,`)})` : ``}`
)
const curryPowder = (fn) => {
  function curried(...args) {
    const length = args.length
    function saucy(...args2) {
      return curried.apply(this, args.concat(args2))
    }
    saucy.toString = toString(fn, args)
    return (
      length >= fn.length ?
      fn.apply(this, args) :
      saucy
    )
  }
  curried.toString = toString(fn)
  return curried
};


const __eq = (l, r) => {
  if (l === r) {
    return true;
  }
  if (typeof l !== typeof r) {
    return false;
  }
  if (typeof l === `object`) {
    if (Array.isArray(l)) {
      return l.reduce((res, _, i) => res && __eq(l[i], r[i]), true);
    }
    const keysL = Object.keys(l);
    const keysR = Object.keys(r);
    return keysL.length === keysR.length && keysL.reduce((res, k) => res && __eq(l[k], r[k]), true);
  }
  return l === r;
}
const getMadlibType = (value) => {
  if (typeof value === 'string') {
    return 'String';
  }
  else {
    return '__UNKNOWN__';
  }
};
export const WriterT = curryPowder((a) => ({ __constructor: "WriterT", __args: [ a ] }));
export const Identity = curryPowder((a) => ({ __constructor: "Identity", __args: [ a ] }));
export const StateT = curryPowder((a) => ({ __constructor: "StateT", __args: [ a ] }));
global.Semigroup = {};
global.Monoid = {};
global.Functor = {};
global.Applicative = {};
global.Monad = {};
global.MonadTrans = {};
global.MonadWriter = {};
global.MonadState = {};
Semigroup['List'] = {
  assoc: curryPowder((xs1, xs2) => xs1.concat(xs2))
};
Monoid['List'] = {
  mappend: curryPowder((xs1, xs2) => xs1.concat(xs2)),
  mempty: ([])
};
Functor['WriterT'] = {
  map: (__Functor_jr__) => (curryPowder((f, m) => WriterT(__Functor_jr__.map(curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [a,w] = __x__;
    return ([f(a), w]);
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__)))(runWriterT(m)))))
};
Applicative['WriterT'] = {
  ap: (__Semigroup_le__) => ((__Monoid_le__) => ((__Functor_lf__) => ((__Applicative_lf__) => (curryPowder((mf, mm) => WriterT(liftA2(__Functor_lf__)(__Applicative_lf__)(curryPowder((x1, x2) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [a,w] = __x__;
    return ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [b,ww] = __x__;
    return ([a(b), __Monoid_le__.mappend(w)(ww)]);
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(x2);
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(x1)))(runWriterT(mf))(runWriterT(mm)))))))),
  pure: (__Semigroup_lv__) => ((__Monoid_lv__) => ((__Functor_lt__) => ((__Applicative_lt__) => (curryPowder((x) => WriterT(__Applicative_lt__.pure(([x, __Monoid_lv__.mempty]))))))))
};
Monad['WriterT'] = {
  chain: (__Functor_nn__) => ((__Applicative_nn__) => ((__Monad_nn__) => ((__Semigroup_nm__) => ((__Monoid_nm__) => (curryPowder((f, m) => WriterT(__Monad_nn__.chain(curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [a,w] = __x__;
    return __Monad_nn__.chain(curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [b,ww] = __x__;
    return __Monad_nn__.of(([b, __Monoid_nm__.mappend(w)(ww)]));
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__)))(runWriterT(f(a)));
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__)))(runWriterT(m))))))))),
  of: (__Functor_ny__) => ((__Applicative_ny__) => ((__Monad_ny__) => ((__Semigroup_nx__) => ((__Monoid_nx__) => (Applicative.WriterT.pure(__Semigroup_nx__)(__Monoid_nx__)(__Functor_ny__)(__Applicative_ny__))))))
};
MonadTrans['m_WriterT'] = {
  lift: (__Semigroup_or__) => ((__Monoid_or__) => ((__Functor_op__) => ((__Applicative_op__) => ((__Monad_op__) => (curryPowder((m) => WriterT(__Monad_op__.chain(curryPowder((a) => __Monad_op__.of(([a, __Monoid_or__.mempty]))))(m))))))))
};
Functor['Identity'] = {
  map: curryPowder((f, m) => Identity(f(runIdentity(m))))
};
Applicative['Identity'] = {
  ap: curryPowder((mf, mm) => Identity(runIdentity(mf)(runIdentity(mm)))),
  pure: Identity
};
Monad['Identity'] = {
  chain: curryPowder((f, mm) => f(runIdentity(mm))),
  of: Applicative.Identity.pure
};
Functor['StateT'] = {
  map: (__Functor_rl__) => (curryPowder((f, m) => StateT(curryPowder((s) => __Functor_rl__.map(curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [a,ss] = __x__;
    return ([f(a), ss]);
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__)))(runStateT(m)(s))))))
};
Applicative['StateT'] = {
  ap: (__Functor_tf__) => ((__Applicative_tf__) => ((__Monad_tf__) => (curryPowder((mf, mm) => StateT(curryPowder((s) => __Monad_tf__.chain(curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [f,ss] = __x__;
    return __Monad_tf__.chain(curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [m,sss] = __x__;
    return __Monad_tf__.of(([f(m), sss]));
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__)))(runStateT(mm)(ss));
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__)))(runStateT(mf)(s)))))))),
  pure: (__Functor_tu__) => ((__Applicative_tu__) => ((__Monad_tu__) => (curryPowder((a) => StateT(curryPowder((s) => __Monad_tu__.of(([a, s]))))))))
};
Monad['StateT'] = {
  chain: (__Functor_vb__) => ((__Applicative_vb__) => ((__Monad_vb__) => (curryPowder((f, m) => StateT(curryPowder((s) => __Monad_vb__.chain(curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [a,ss] = __x__;
    return runStateT(f(a))(ss);
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__)))(runStateT(m)(s)))))))),
  of: (__Functor_vq__) => ((__Applicative_vq__) => ((__Monad_vq__) => (curryPowder((a) => StateT(curryPowder((s) => __Monad_vq__.of(([a, s]))))))))
};
MonadTrans['m_StateT'] = {
  lift: (__Functor_wl__) => ((__Applicative_wl__) => ((__Monad_wl__) => (curryPowder((m) => StateT(curryPowder((s) => __Monad_wl__.chain(curryPowder((a) => __Monad_wl__.of(([a, s]))))(m)))))))
};
MonadWriter['w_WriterT'] = {
  tell: (__Functor_wy__) => ((__Applicative_wy__) => ((__Monad_wy__) => ((__Semigroup_ws__) => ((__Monoid_ws__) => (curryPowder((v) => WriterT(__Monad_wy__.of(([({ __constructor: "Unit", __args: [] }), v])))))))))
};
MonadWriter['w_StateT'] = {
  tell: (__Functor_xp__) => ((__Applicative_xp__) => ((__Semigroup_xn__) => ((__Monad_xp__) => ((__Monoid_xn__) => ((__MonadWriter_xn_xp__) => ((__Functor_xp__) => ((__Applicative_xp__) => ((__Monad_xp__) => ((__Semigroup_xn__) => ((__Monoid_xn__) => (curryPowder((__x__) => MonadTrans.m_StateT.lift(__Functor_xp__)(__Applicative_xp__)(__Monad_xp__)(__MonadWriter_xn_xp__.tell(__x__))))))))))))))
};
MonadState['s_StateT'] = {
  get: (__Functor_yd__) => ((__Applicative_yd__) => ((__Monad_yd__) => (StateT(curryPowder((s) => __Monad_yd__.of(([s, s]))))))),
  modify: (__Functor_yq__) => ((__Applicative_yq__) => ((__Monad_yq__) => (curryPowder((f) => StateT(curryPowder((s) => __Monad_yq__.of(([({ __constructor: "Unit", __args: [] }), f(s)])))))))),
  put: (__Functor_ze__) => ((__Applicative_ze__) => ((__Monad_ze__) => (curryPowder((s) => StateT(curryPowder((_) => __Monad_ze__.of(([({ __constructor: "Unit", __args: [] }), s]))))))))
};
MonadState['s_WriterT'] = {
  get: (__Functor_zp__) => ((__Applicative_zp__) => ((__Monad_zp__) => ((__MonadState_zo_zp__) => ((__Functor_zp__) => ((__Applicative_zp__) => ((__Monad_zp__) => ((__Semigroup_zq__) => ((__Monoid_zq__) => (MonadTrans.m_WriterT.lift(__Semigroup_zq__)(__Monoid_zq__)(__Functor_zp__)(__Applicative_zp__)(__Monad_zp__)(__MonadState_zo_zp__.get)))))))))),
  modify: (__Functor_aag__) => ((__Applicative_aag__) => ((__Monad_aag__) => ((__MonadState_aae_aag__) => ((__Functor_aag__) => ((__Applicative_aag__) => ((__Monad_aag__) => ((__Semigroup_aaj__) => ((__Monoid_aaj__) => (curryPowder((__x__) => MonadTrans.m_WriterT.lift(__Semigroup_aaj__)(__Monoid_aaj__)(__Functor_aag__)(__Applicative_aag__)(__Monad_aag__)(__MonadState_aae_aag__.modify(__x__)))))))))))),
  put: (__Functor_aaz__) => ((__Applicative_aaz__) => ((__Monad_aaz__) => ((__MonadState_aax_aaz__) => ((__Functor_aaz__) => ((__Applicative_aaz__) => ((__Monad_aaz__) => ((__Semigroup_abc__) => ((__Monoid_abc__) => (curryPowder((__x__) => MonadTrans.m_WriterT.lift(__Semigroup_abc__)(__Monoid_abc__)(__Functor_aaz__)(__Applicative_aaz__)(__Monad_aaz__)(__MonadState_aax_aaz__.put(__x__))))))))))))
};
export const andDo = (__Functor_i__) => ((__Applicative_i__) => ((__Monad_i__) => (curryPowder((b, a) => __Monad_i__.chain(curryPowder((_) => b))(a)))));
export const runWriterT = curryPowder((__x__) => ((__x__) => {
  if (__x__.__constructor === "WriterT" && true) {
    const m = __x__.__args[0];
    return m;
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__));
const liftA2 = (__Functor_am__) => ((__Applicative_am__) => (curryPowder((f, x1, x2) => __Applicative_am__.ap(__Functor_am__.map(f)(x1))(x2))));
export const runIdentity = curryPowder((__x__) => ((__x__) => {
  if (__x__.__constructor === "Identity" && true) {
    const a = __x__.__args[0];
    return a;
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(__x__));
export const runStateT = curryPowder((m) => ((__x__) => {
  if (__x__.__constructor === "StateT" && true) {
    const f = __x__.__args[0];
    return curryPowder((a) => f(a));
  }
  else { console.log('non exhaustive patterns for value: ', __x__.toString()); 
throw 'non exhaustive patterns!'; }
})(m));
const hep = (__Functor_bn__) => ((__Applicative_bn__) => ((__Semigroup_bm__) => ((__Monad_bn__) => ((__Monoid_bm__) => ((__MonadWriter_bm_bn__) => (__MonadWriter_bm_bn__.tell))))));
const sumAndLog = (__Functor_dg__) => ((__Applicative_dg__) => ((__Monad_dg__) => ((__MonadWriter_List_dg__) => (curryPowder((__x__) => __Monad_dg__.chain(curryPowder((x) => andDo(__Functor_dg__)(__Applicative_dg__)(__Monad_dg__)(__Monad_dg__.of(x))(__MonadWriter_List_dg__.tell(([`Summed 18`])))))(__Monad_dg__.chain(curryPowder((x) => __Monad_dg__.of(x + 18)))(__Monad_dg__.of(__x__))))))));
const runStack = curryPowder((x, m) => curryPowder((__x__) => runIdentity(runWriterT(curryPowder((m) => runStateT(m)(x))(__x__))))(m));
runStack(37)(Monad.StateT.chain(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(sumAndLog(Object.keys(Functor.StateT).reduce((o, k) => ({...o, [k]: Functor.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))}), {}))(Object.keys(Applicative.StateT).reduce((o, k) => ({...o, [k]: Applicative.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Object.keys(Monad.StateT).reduce((o, k) => ({...o, [k]: Monad.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Object.keys(MonadWriter.w_StateT).reduce((o, k) => ({...o, [k]: MonadWriter.w_StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Semigroup.List)(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Monoid.List)(Object.keys(MonadWriter.w_WriterT).reduce((o, k) => ({...o, [k]: MonadWriter.w_WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Semigroup.List)(Monoid.List)}), {})))(andDo(Object.keys(Functor.StateT).reduce((o, k) => ({...o, [k]: Functor.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))}), {}))(Object.keys(Applicative.StateT).reduce((o, k) => ({...o, [k]: Applicative.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Object.keys(Monad.StateT).reduce((o, k) => ({...o, [k]: Monad.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Monad.StateT.of(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(5))(Monad.StateT.chain(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(curryPowder((_) => hep(Object.keys(Functor.StateT).reduce((o, k) => ({...o, [k]: Functor.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))}), {}))(Object.keys(Applicative.StateT).reduce((o, k) => ({...o, [k]: Applicative.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Semigroup.List)(Object.keys(Monad.StateT).reduce((o, k) => ({...o, [k]: Monad.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Monoid.List)(Object.keys(MonadWriter.w_StateT).reduce((o, k) => ({...o, [k]: MonadWriter.w_StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Semigroup.List)(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Monoid.List)(Object.keys(MonadWriter.w_WriterT).reduce((o, k) => ({...o, [k]: MonadWriter.w_WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Semigroup.List)(Monoid.List)}), {}))(([`HAP`]))))(Monad.StateT.chain(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(curryPowder((_) => MonadState.s_StateT.put(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(157)))(Monad.StateT.chain(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(curryPowder((_) => hep(Object.keys(Functor.StateT).reduce((o, k) => ({...o, [k]: Functor.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))}), {}))(Object.keys(Applicative.StateT).reduce((o, k) => ({...o, [k]: Applicative.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Semigroup.List)(Object.keys(Monad.StateT).reduce((o, k) => ({...o, [k]: Monad.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Monoid.List)(Object.keys(MonadWriter.w_StateT).reduce((o, k) => ({...o, [k]: MonadWriter.w_StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Semigroup.List)(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Monoid.List)(Object.keys(MonadWriter.w_WriterT).reduce((o, k) => ({...o, [k]: MonadWriter.w_WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Semigroup.List)(Monoid.List)}), {}))(([`HIP`]))))(Monad.StateT.chain(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(curryPowder((_) => hep(Object.keys(Functor.StateT).reduce((o, k) => ({...o, [k]: Functor.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))}), {}))(Object.keys(Applicative.StateT).reduce((o, k) => ({...o, [k]: Applicative.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Semigroup.List)(Object.keys(Monad.StateT).reduce((o, k) => ({...o, [k]: Monad.StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))}), {}))(Monoid.List)(Object.keys(MonadWriter.w_StateT).reduce((o, k) => ({...o, [k]: MonadWriter.w_StateT[k](Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Semigroup.List)(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Monoid.List)(Object.keys(MonadWriter.w_WriterT).reduce((o, k) => ({...o, [k]: MonadWriter.w_WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(Semigroup.List)(Monoid.List)}), {}))(([`HOP`]))))(Functor.StateT.map(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(curryPowder((x) => x * 17))(Monad.StateT.chain(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(curryPowder((x) => Monad.StateT.of(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(29 * x)))(Monad.StateT.of(Object.keys(Functor.WriterT).reduce((o, k) => ({...o, [k]: Functor.WriterT[k](Functor.Identity)}), {}))(Object.keys(Applicative.WriterT).reduce((o, k) => ({...o, [k]: Applicative.WriterT[k](Semigroup.List)(Monoid.List)(Functor.Identity)(Applicative.Identity)}), {}))(Object.keys(Monad.WriterT).reduce((o, k) => ({...o, [k]: Monad.WriterT[k](Functor.Identity)(Applicative.Identity)(Monad.Identity)(Semigroup.List)(Monoid.List)}), {}))(3))))))))));
export default { andDo, runWriterT, runIdentity, runStateT, WriterT, Identity, StateT };
