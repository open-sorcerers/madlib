// file: path
const toString = (fn, args = []) => () => (
  `curry(${fn.toString()})${args.length > 0 ? `(${args.join(`,`)})` : ``}`
)
const curryPowder = (fn) => {
  function curried(...args) {
    const length = args.length
    function saucy(...args2) {
      return curried.apply(this, args.concat(args2))
    }
    saucy.toString = toString(fn, args)
    return (
      length >= fn.length ?
      fn.apply(this, args) :
      saucy
    )
  }
  curried.toString = toString(fn)
  return curried
};


const __eq = (l, r) => {
  if (l === r) {
    return true;
  }
  if (typeof l !== typeof r) {
    return false;
  }
  if (typeof l === `object`) {
    if (Array.isArray(l)) {
      return l.reduce((res, _, i) => res && __eq(l[i], r[i]), true);
    }
    const keysL = Object.keys(l);
    const keysR = Object.keys(r);
    return keysL.length === keysR.length && keysL.reduce((res, k) => res && __eq(l[k], r[k]), true);
  }
  return l === r;
}
const getMadlibType = (value) => {
  if (typeof value === 'string') {
    return 'String';
  }
  else {
    return '__UNKNOWN__';
  }
};
export const Show = {};
Show['Boolean'] = {
  show: curryPowder((b) => (b ? `True` : `False`))
};
Show['Number'] = {
  show: curryPowder((n) => new Number(n).toString())
};
Show['Tuple_2'] = {
  show: (__Show_z__) => ((__Show_y__) => (curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 2 && true && true) {
    const [a,b] = __x__;
    return `<` + __Show_y__.show(a) + `, ` + __Show_z__.show(b) + `>`;
  }
  else { throw 'non exhaustive patterns!'; }
})(__x__))))
};
Show['Tuple_3'] = {
  show: (__Show_at__) => ((__Show_as__) => ((__Show_ar__) => (curryPowder((__x__) => ((__x__) => {
  if (__x__.length === 3 && true && true && true) {
    const [a,b,c] = __x__;
    return `<` + __Show_ar__.show(a) + `, ` + __Show_as__.show(b) + `, ` + __Show_at__.show(c) + `>`;
  }
  else { throw 'non exhaustive patterns!'; }
})(__x__)))))
};
Show['Either'] = {
  show: (__Show_cb__) => ((__Show_ce__) => (curryPowder((__x__) => ((__x__) => {
  if (__x__.__constructor === "Right" && true) {
    const a = __x__.__args[0];
    return `Right ` + __Show_ce__.show(a);
  }
  else if (__x__.__constructor === "Left" && true) {
    const e = __x__.__args[0];
    return `Left ` + __Show_cb__.show(e);
  }
  else { throw 'non exhaustive patterns!'; }
})(__x__))))
};
const Right = curryPowder((a) => ({ __constructor: "Right", __args: [ a ] }));
const Left = curryPowder((a) => ({ __constructor: "Left", __args: [ a ] }));
Show.Tuple_2.show(Show.Boolean)(Show.Number)(([1, false]));
Show.Either.show(Show.Number)(Show.Number)(Right(3));
Show.Tuple_2.show(Show.Number)(Show.Number)(([1, 1]));
Show.Tuple_3.show(Show.Boolean)(Show.Number)(Show.Boolean)(([false, 42, true]));
