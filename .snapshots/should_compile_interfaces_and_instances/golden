// file: path
const toString = (fn, args = []) => () => (
  `curry(${fn.toString()})${args.length > 0 ? `(${args.join(`,`)})` : ``}`
)
const curryPowder = (fn) => {
  function curried(...args) {
    const length = args.length
    function saucy(...args2) {
      return curried.apply(this, args.concat(args2))
    }
    saucy.toString = toString(fn, args)
    return (
      length >= fn.length ?
      fn.apply(this, args) :
      saucy
    )
  }
  curried.toString = toString(fn)
  return curried
};


const __eq = (l, r) => {
  if (l === r) {
    return true;
  }
  if (typeof l !== typeof r) {
    return false;
  }
  if (typeof l === `object`) {
    if (Array.isArray(l)) {
      return l.reduce((res, _, i) => res && __eq(l[i], r[i]), true);
    }
    const keysL = Object.keys(l);
    const keysR = Object.keys(r);
    return keysL.length === keysR.length && keysL.reduce((res, k) => res && __eq(l[k], r[k]), true);
  }
  return l === r;
}
const getMadlibType = (value) => {
  if (typeof value === 'string') {
    return 'String';
  }
  else {
    return '__UNKNOWN__';
  }
};
export const Functor = {};
export const Monad = {};
Functor['Maybe'] = {
  map: curryPowder((f, __x__) => ((__x__) => {
  if (__x__.__constructor === "Just" && true) {
    const x = __x__.__args[0];
    return Just(f(x));
  }
  else if (__x__.__constructor === "Nothing") {
    return Nothing;
  }
  else { throw 'non exhaustive patterns!'; }
})(__x__))
};
Functor['List'] = {
  map: curryPowder((f, __x__) => ((__x__) => {
  if (__x__.length >= 2 && true && true) {
    const [h,...t] = __x__;
    return ([f(h),  ...Functor.List.map(f, t)]);
  }
  else if (__x__.length === 1 && true) {
    const [l] = __x__;
    return ([f(l)]);
  }
  else if (__x__.length === 0) {
    const [] = __x__;
    return ([]);
  }
  else { throw 'non exhaustive patterns!'; }
})(__x__))
};
Monad['Maybe'] = {
  chain: curryPowder((f, __x__) => ((__x__) => {
  if (__x__.__constructor === "Just" && true) {
    const x = __x__.__args[0];
    return f(x);
  }
  else if (__x__.__constructor === "Nothing") {
    return Nothing;
  }
  else { throw 'non exhaustive patterns!'; }
})(__x__)),
  of: curryPowder((x) => Just(x))
};
Monad['Either'] = {
  chain: curryPowder((f, __x__) => ((__x__) => {
  if (__x__.__constructor === "Right" && true) {
    const x = __x__.__args[0];
    return f(x);
  }
  else if (__x__.__constructor === "Left" && true) {
    const e = __x__.__args[0];
    return Left(e);
  }
  else { throw 'non exhaustive patterns!'; }
})(__x__)),
  of: curryPowder((x) => Right(x))
};
const Just = curryPowder((a) => ({ __constructor: "Just", __args: [ a ] }));
const Nothing = ({ __constructor: "Nothing", __args: [  ] });
const Right = curryPowder((a) => ({ __constructor: "Right", __args: [ a ] }));
const Left = curryPowder((a) => ({ __constructor: "Left", __args: [ a ] }));
const inc = curryPowder((a) => a + 1);
Functor.List.map(inc, ([1, 2, 3]));
Monad.Maybe.chain(curryPowder((x) => Just(x + 1)), Just(3));
const doIt = (__Functor_ae__) => (curryPowder((x) => __Functor_ae__.map(curryPowder((k) => k + 1), x)));
doIt(Functor.Maybe)(Just(3));
const p = 1;
const fn = (__Functor_av__) => (__Functor_av__.map(inc));
fn(Functor.Maybe)(Just(3));
fn(Functor.List)(([4, 5, 6]));
const hideCall = curryPowder((x) => ((__x__) => {
  if (__x__.__constructor === "Just" && __x__.__args[0] === 2) {
    return Monad.Either.chain(curryPowder((a) => Right(a + 1)), Right(2));
  }
  else { throw 'non exhaustive patterns!'; }
})(Monad.Maybe.chain(curryPowder((a) => Just(a + 1)), x)));
