fn2 = (a) => where(a) {
  is { x: x, ...b }: b.z
  is { x: x }: x
}

// fn2 = (a) => where(a) {
//   is { z: z }: z
//   is { x: x }: x
// }

// x = 2
// y = 1 + x

// inc = (x) => x + 1

// inc(4)

// 1 == 2

data Maybe a = Just a | Nothing

// Just(3)
// Nothing

// where(Just(3))
//   is Just n: n

// where(1) {
//   is 1: 3
//   is n: n
// }

// if (true) {
//   3
// } else {
//   4
// }

// xs = [1, 2, 3]
// [1, ...xs]

// <1, "2">

// r = { a: 3, b: "ok", c: [1, 2, 3] }

// r.a + x


// fn = (x) => x + 1
// fn(2)

// getA :: Maybe a -> a
// getA = where
//   is Just a: a

// import F from "Function"
// import IO from "IO"

// fn = (r) => r.a.b.c.d.e

// 3 > 3 + 5

// fib = (n) => (if (n < 2) { n } else { fib(n - 1) + fib(n - 2) })

alias T a = Maybe a

// x :: T String
// x = Just("ok")

export data ByteArray = ByteArray (List String)

// map :: (a -> b) -> List a -> List b
map = (f, xs) => (#- some JS -#)


map(
  map((x) => x + 1),
  [[1, 2]]
)

// map(map((x) => x + 1), [[1, 2], [3, 4]])
// [[1, 2], [3, 4]]
//   |> map(map((x) => (x * 2)))
