import IO from "IO"

data Maybe a = Just a | Nothing

data Either e a = Right a | Left e

interface Functor m {
  map :: (a -> b) -> m a -> m b
}

instance Functor Maybe {
  map = (f) => where
    is Just x : Just(f(x))
    is Nothing: Nothing
}

instance Functor List {
  map = (f) => where
    is [h, ...t]: [f(h), ...map(f, t)]
    is [l]      : [f(l)]
    is []       : []
}

interface Monad m {
  chain :: (a -> m b) -> m a -> m b
  of :: a -> m a
}

instance Monad Maybe {
  chain = (f) => where
    is Just x : f(x)
    is Nothing: Nothing

  of = (x) => Just(x)
}

instance Monad (Either e) {
  chain = (f) => where
    is Right x: f(x)
    is Left e : Left(e)

  of = (x) => Right(x)
}

// interface Read a {
//   read :: String -> a
// }

// instance Read Number {
//   read = (x) => (#- -#)
// }

inc = (a) => a + 1

map(inc, [1, 2 ,3]) |> IO.log

chain((x) => Just(x + 1), Just(3))

doIt = (x) => map((k) => k + 1, x)

doIt(Just(3)) |> map(IO.log)


fn = map(inc)

fn(Just(3)) |> IO.log
fn([4, 5, 6]) |> IO.log
// fn(Right(4)) |> IO.log

hideCall = (x) =>
  where(chain((a) => Just(a + 1), x))
    is Just 2: chain((a) => Right(a + 1), Right(2))


shadow = where
  is Just x : x
  is Nothing: 1

