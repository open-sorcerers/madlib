import L from "List"
import W from "Wish"
import Math from "Math"
import IO from "IO"
import Http from "Http"
import B from "Binary"
import FS from "FileSystem"
import M from "Map"
import Maybe from "Maybe"
import J from "Json"
import E from "Either"
import S from "System"
import String from "String"


FS.readFile("madlib.json")
  |> W.map(J.parse(J.field("dependencies", J.map(J.string))))
  |> W.chain((dm) => (where(dm)
    is E.Left e: W.bad(e)
    is E.Right depMap:
      M.keys(depMap)
        |> L.map((key) => (
            M.get(key, depMap)
              |> (path) => (where(path)
                   is Maybe.Just p : Http.get(p)
                   is Maybe.Nothing: W.bad("ERR")
                 )
              |> W.map((res) => (where(res)
                   is Http.Response { body: Http.BinaryBody d }: d
                 ))
              |> W.map(FS.BinaryData)
              |> W.chain(FS.writeFile(key ++ ".zip"))
              |> W.chain((a) => (S.exec("mv " ++ a ++ " ./madlib_modules/")))
              |> W.chain((a) => (S.exec("unzip -d ./madlib_modules/" ++ key ++ "-tmp ./madlib_modules/" ++ key ++ ".zip")))
              |> W.chain((a) => (S.exec("mv ./madlib_modules/" ++ key ++ "-tmp/* ./madlib_modules/" ++ key ++ "-tmp/" ++ key)))
              |> W.chain((a) => (S.exec("cp -R ./madlib_modules/" ++ key++"-tmp/"++key++" ./madlib_modules/")))
              |> W.chain((a) => (S.exec("rm -r ./madlib_modules/" ++ key ++ ".zip ./madlib_modules/" ++ key ++ "-tmp")))
          ))
        |> W.parallel
     ))
  |> W.fulfill(IO.err, IO.log)
