import L from "List"
import W from "Wish"
import Math from "Math"
import IO from "IO"
import Http from "Http"
import B from "Binary"
import FS from "FileSystem"
import M from "Map"
import Maybe from "Maybe"
import J from "Json"
import E from "Either"
import S from "System"
import F from "Function"


// W.of(3)
//   |> W.chain((x) => (W.of(x - 1)))
//   |> W.chain((x) => (W.bad("BAD")))
//   |> W.map((x) => (x * 2))
//   |> W.map(IO.log)
//   |> W.mapRej((x) => (x == "OK"))
//   |> W.fulfill(IO.log, IO.log)


// L.filter((x) => (x == 2), [1, 2, 3, 4]) |> IO.log
// L.reject((x) => (x == 2), [1, 2, 3, 4]) |> IO.log

// Math.mod(3, 7) |> IO.log


// FS.readFile("README.md")
//   |> W.fulfill(IO.log, IO.log)


// W.of(`{"dependencies": { "fluture": "https://github.com/fluture-js/Fluture/archive/master.zip" }}`)

FS.readFile("madlib.json")
  |> W.map(J.parse(J.field("dependencies", J.map(J.string))))
  |> W.chain((dm) => (where(dm)
    is E.Left e: W.bad(e)
    is E.Right depMap:
      M.keys(depMap)
        |> L.map((key) => (
            M.get(key, depMap)
              |> (path) => (where(path)
                   is Maybe.Just p : Http.get(p)
                   is Maybe.Nothing: W.bad("ERR")
                 )
              |> W.map((res) => (where(res)
                   is Http.Response { body: Http.BinaryBody d }: d
                 ))
              |> W.map(FS.BinaryData)
              |> W.chain(FS.writeFile(key ++ ".zip"))
              |> W.chain((a) => (S.exec("mv " ++ a ++ " ./madlib_modules/")))
              |> W.chain((a) => (S.exec("unzip -d ./madlib_modules/" ++ key ++ "-tmp ./madlib_modules/" ++ key ++ ".zip")))
              |> W.chain((a) => (S.exec("mv ./madlib_modules/" ++ key ++ "-tmp/* ./madlib_modules/" ++ key ++ "-tmp/" ++ key)))
              |> W.chain((a) => (S.exec("cp -R ./madlib_modules/" ++ key++"-tmp/"++key++" ./madlib_modules/")))
              |> W.chain((a) => (S.exec("rm -r ./madlib_modules/" ++ key ++ ".zip ./madlib_modules/" ++ key ++ "-tmp")))
          ))
        |> W.parallel
     ))
  |> W.fulfill(IO.log, IO.log)

