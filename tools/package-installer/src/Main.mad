import L from "List"
import W from "Wish"
import Math from "Math"
import IO from "IO"
import Http from "Http"
import B from "Binary"
import FS from "FileSystem"
import M from "Map"
import Maybe from "Maybe"
import J from "Json"
import E from "Either"
import S from "System"
import String from "String"
import F from "Function"


IO.log("Installing dependencies ...")

// installPackages :: String -> ()
installPackages = pipe(
  FS.readFile,
  W.mapRej((_) => ("The madlib.json file was not found, verify that you have created one or that you run the command from the right directory.")),
  map(J.parse(J.field("dependencies", J.map(J.string)))),
  W.chain(where
    is E.Left e: W.bad(e)
    is E.Right depMap: pipe(
      M.keys,
      (keys) => IO.trace("Packages to install:" ++ L.reduceR((ptis, k) => (ptis ++ "\n" ++ "  - " ++ k), "", keys) ++ "\n", keys),
      map((key) => pipe(
        (k) => M.get(k, depMap),
        where
          is Maybe.Just p : Http.get(p)
          is Maybe.Nothing: W.bad("ERR"),
        map(where is Http.Response { body: Http.BinaryBody d }: d),
        map(FS.BinaryData),
        W.chain(FS.writeFile(key ++ ".zip")),
        W.chain((a) => S.exec("mv " ++ a ++ " ./madlib_modules/")),
        W.andDo(S.exec("unzip -d ./madlib_modules/" ++ key ++ "-tmp ./madlib_modules/" ++ key ++ ".zip")),
        W.andDo(S.exec("mv ./madlib_modules/" ++ key ++ "-tmp/* ./madlib_modules/" ++ key ++ "-tmp/" ++ key)),
        W.andDo(S.exec("cp -R ./madlib_modules/" ++ key++"-tmp/"++key++" ./madlib_modules/")),
        W.andDo(S.exec("rm -r ./madlib_modules/" ++ key ++ ".zip ./madlib_modules/" ++ key ++ "-tmp")),
        map((a) => "package " ++ key ++ " installed"),
        W.mapRej((_) => "Error installing package '" ++ key ++ "'")
      )(key)),
      W.parallel
    )(depMap)
  ),
  W.fulfill(pipe(IO.log, F.always(())), pipe(IO.log, F.always(())))
)



installPackages("madlib.json")
